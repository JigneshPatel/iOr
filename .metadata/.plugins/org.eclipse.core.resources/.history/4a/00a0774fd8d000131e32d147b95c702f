package com.tcv.util;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.entity.BufferedHttpEntity;
import org.apache.http.impl.client.DefaultHttpClient;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Point;
import android.graphics.drawable.ColorDrawable;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.NetworkInfo.State;
import android.os.AsyncTask;
import android.os.Environment;
import android.text.TextUtils;
import android.text.format.DateFormat;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.Display;
import android.view.Gravity;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.widget.ArrayAdapter;
import android.widget.TextView;
import android.widget.Toast;

import com.itextpdf.text.BaseColor;
import com.itextpdf.text.Chunk;
import com.itextpdf.text.Document;
import com.itextpdf.text.Font;
import com.itextpdf.text.Image;
import com.itextpdf.text.Paragraph;
import com.itextpdf.text.Phrase;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.codec.PngImage;
import com.tcv.callback.IOnSaveListener;
import com.tcv.controller.ActionUpdateListener;
import com.tcv.controller.R;
import com.tcv.controller.TestContentManager;
import com.tcv.model.Exception.DiagnosisdetailsException;
import com.tcv.model.manager.DiagnosisdetailsManager;
import com.tcv.model.pojo.Diagnosisdetails;
import com.tcv.model.pojo.ReportItem;
import com.tcv.model.pojo.TestInfo;
import com.tcv.model.pojo.Testsummary;
import com.tcv.model.pojo.UserRegistration;

/**
 * Android Utility class which is used to handle the different Android utility
 * functions.
 * 
 * @author surya
 * 
 */
@SuppressLint("SimpleDateFormat")
public class AndroidUtility {

	private static Pattern pattern;
	private static Matcher matcher;
	private static Context contxt;
	static DiagnosisdetailsManager diagnosisManager;
	private static Diagnosisdetails mDiagnosisDetails;
	private static String mfName, mLName, mTestName, mCreatedDate,
			mDiagnosisMsg, mScoreMsg;
	public static String printPDFpath;
	static Testsummary testsummary;
	static ArrayList<Testsummary> childList;

	/**
	 * To get the device SDK version.
	 * 
	 * @return Android SDK version as an integer. Works on all versions
	 */
	public static int getSdkVersion() {
		return Integer.parseInt(android.os.Build.VERSION.SDK);
	}

	/**
	 * /*** To clear the application cache
	 * 
	 * @param context
	 */
	public static void clearCache(Context context) {
		try {
			File dir = context.getCacheDir();
			if (dir != null && dir.isDirectory()) {
				deleteDir(dir);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public static byte[] getBytesFromFile(String imagePath) {
		File file = new File(imagePath);
		byte[] bytes = null;
		try {
			InputStream is = new FileInputStream(file);
			long length = file.length();
			bytes = new byte[(int) length];
			int offset = 0;
			int numRead = 0;
			while (offset < bytes.length
					&& (numRead = is.read(bytes, offset, bytes.length - offset)) >= 0) {
				offset += numRead;
			}
			if (offset < bytes.length) {
				throw new IOException("Could not completely read file "
						+ file.getName());
			}
			is.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return bytes;
	}

	public static boolean deleteDir(File dir) {
		try {
			if (dir != null && dir.isDirectory()) {
				String[] children = dir.list();
				for (int i = 0; i < children.length; i++) {
					boolean success = deleteDir(new File(dir, children[i]));
					if (!success) {
						return false;
					}
				}
			}
			return dir.delete();
		} catch (Exception e) {

			e.printStackTrace();
			return false;
		}
	}

	/**
	 * This method is use to check the device internet connectivity.
	 * 
	 * @param context
	 * @return true :if your device is connected to internet. false :if your
	 *         device is not connected to internet.
	 */
	public static boolean isConnected(Context context) {
		ConnectivityManager manager = (ConnectivityManager) context
				.getSystemService(Context.CONNECTIVITY_SERVICE);
		NetworkInfo info = manager.getActiveNetworkInfo();
		if (info == null)
			return false;
		if (info.getState() != State.CONNECTED)
			return false;
		return true;
	}

	/**
	 * Fetch the image specified by the given url.
	 * 
	 * @param url
	 *            : Image url for download.
	 * @return bitmap: Downloaded bitmap image.
	 * @throws IOException
	 */
	public static Bitmap fetchImage(URL url) throws IOException {
		InputStream is = null;
		try {
			URLConnection conn = url.openConnection();
			conn.connect();
			is = conn.getInputStream();
			BufferedInputStream bis = new BufferedInputStream(is, 16384);
			try {
				Bitmap bitmap = BitmapFactory.decodeStream(bis);
				return bitmap;
			} finally {
				bis.close();
			}
		} finally {
			if (is != null)
				is.close();
		}
	}

	/**
	 * To convert the image from byte array to bitmap.
	 * 
	 * @param imgByteArray
	 *            : byte array of image.
	 * @return Image in bitmap.
	 */
	public static Bitmap converImgByteToBitmap(byte[] imgByteArray) {
		Bitmap bitmap = null;
		return bitmap;

	}

	/**
	 * To conver Image from bitmap to byte array.
	 * 
	 * @param bitmapImage
	 *            : bitmap image.
	 * @return byte array of image.
	 */
	public static byte[] convertImfBitmapToByteArray(Bitmap bitmapImage) {
		return null;
	}

	/**
	 * To post some data to the server.
	 * 
	 * @param url
	 *            : URL on which we want to post the data on it.
	 * @param param
	 *            : data which we want to post on server.
	 * @return result: success of fail.
	 */
	public static String postDataToServer(String url, String[] param) {
		String result = null;
		return result;
	}

	/**
	 * To upload the image on server.
	 * 
	 * @param url
	 *            : server url which we want to upload the image.
	 * @param filePath
	 *            : Image file location.
	 */
	public static void uploadImageToServer(String url, String filePath) {

	}

	/**
	 * To upload the video on server.
	 * 
	 * @param url
	 *            : server url which we want to upload the video.
	 * @param filePath
	 *            : Video file path.
	 */
	public static void uploadVideoToServer(String url, String filePath) {

	}

	/**
	 * This function is used to write the SQLite create table query.
	 * 
	 * @param tableName
	 *            : String table name which we want to create.
	 * @param fieldName
	 *            : String array that defines the coloum names.
	 * @param dataType
	 *            : String array of data type respective of the column names.
	 * @return Generated create table query string.
	 */
	public static String createTableQuery(String tableName, String[] fieldName,
			String[] dataType) {
		StringBuilder createTableQuery = new StringBuilder();

		createTableQuery.append("create table " + tableName + " (");

		for (int i = 0; i < fieldName.length; i++) {
			if (i == 0)
				createTableQuery.append(fieldName[i] + " " + dataType[i]
						+ " not null");
			else
				createTableQuery.append("," + fieldName[i] + " " + dataType[i]
						+ " not null");
		}
		createTableQuery.append(");");
		return createTableQuery.toString();
	}

	/**
	 * This function is used to check the email validation.
	 * 
	 * @param email
	 *            : email string
	 * @return true if email id is valid else return false.
	 */
	public static boolean isEmailValid(String email) {
		String regExpn = "^(([\\w-]+\\.)+[\\w-]+|([a-zA-Z]{1}|[\\w-]{2,}))@"
				+ "((([0-1]?[0-9]{1,2}|25[0-5]|2[0-4][0-9])\\.([0-1]?"
				+ "[0-9]{1,2}|25[0-5]|2[0-4][0-9])\\."
				+ "([0-1]?[0-9]{1,2}|25[0-5]|2[0-4][0-9])\\.([0-1]?"
				+ "[0-9]{1,2}|25[0-5]|2[0-4][0-9])){1}|"
				+ "([a-zA-Z]+[\\w-]+\\.)+[a-zA-Z]{2,4})$";

		CharSequence inputStr = email;

		pattern = Pattern.compile(regExpn, Pattern.CASE_INSENSITIVE);
		matcher = pattern.matcher(inputStr);

		if (matcher.matches())
			return true;
		else
			return false;

	}

	// Some Basic java operations.

	/**
	 * Capitalize the first character
	 * 
	 * @param string
	 *            which we you want to Capitalize the first character.
	 * @return string after Capitalize the first character
	 */
	public static String capitalize(String string) {
		return string;

	}

	public static ArrayAdapter<String> spinner_Adapter(Activity activity,
			ArrayList<String> array) {
		return new ArrayAdapter<String>(activity,
				android.R.layout.simple_spinner_item, array) {
			public View getView(int position, View convertView, ViewGroup parent) {
				View v = super.getView(position, convertView, parent);
				((TextView) v).setPadding(20, 5, 25, 5);
				((TextView) v).setMaxLines(1);
				// ((TextView) v).setEllipsize(TruncateAt.END);
				return v;
			}

			public View getDropDownView(int position, View convertView,
					ViewGroup parent) {
				View v = super.getDropDownView(position, convertView, parent);
				return v;
			}
		};
	}

	public static void downloadPDFDocument(Context context, String TestInfoId,
			boolean isSavePdf, ReportItem item, boolean isForSendEmail,
			boolean isPrintPdf) {
		downloadPDFDocument(context, TestInfoId, isSavePdf, item,
				isForSendEmail, isPrintPdf, null);
	}

	public static void downloadPDFDocument(Context context, String TestInfoId,
			boolean isSavePdf, ReportItem item, boolean isForSendEmail,
			boolean isPrintPdf, IOnSaveListener saveListener) {
		contxt = context;
		TestInfo info = item.getTestInfo();
		Log.d("info", "==" + info) ;
		UserRegistration userRegistration = item.getUserRegistration();
		
		Log.d("info", "==" + info) ;
		Log.d("userRegistration", "==" + userRegistration) ;
		Log.d("item", "==" + item) ;
		Log.d("isForSendEmail", "==" + isForSendEmail) ;
		
		new CreatePdf(context, info, userRegistration, isSavePdf, item,
				isForSendEmail, isPrintPdf, saveListener).execute();
	}

	/**
	 * 
	 * Creates Certificate in PDF format.
	 * 
	 */
	@SuppressLint("NewApi")
	public static class CreatePdf extends AsyncTask<String, String, String> {
		boolean success = false;
		String sdCardLocation = Environment.getExternalStoragePublicDirectory(
				Environment.DIRECTORY_DOWNLOADS).toString();
		Dialog progresDialog;
		TextView progressTxt;
		String message;
		TestInfo testInfo;
		UserRegistration mUserReg = null;
		Bitmap bitmap;
		File imagefile;
		Context contxt;
		boolean isSavePdf;
		ReportItem reportItem;
		boolean isForSendEmail;
		boolean isColorShown;
		boolean isPrintPdf;
		String filename;
		String pdfIntentValue;
		Intent pdfIntent;
		private IOnSaveListener saveListener;

		public CreatePdf(Context context, TestInfo info,
				UserRegistration regiInfo, boolean isSavePdf, ReportItem item,
				boolean isForSendEmail, boolean isPrintPdf,
				IOnSaveListener saveListener) {
			reportItem = item;
			testInfo = info;
			mUserReg = regiInfo;
			contxt = context;
			this.isSavePdf = isSavePdf;
			this.isForSendEmail = isForSendEmail;
			this.isPrintPdf = isPrintPdf;
			this.saveListener = saveListener;
		}

		@Override
		protected void onPreExecute() {
			progresDialog = new Dialog(contxt, R.style.Theme_Levels);
			Display payNowdisp = ((Activity) contxt).getWindowManager()
					.getDefaultDisplay();
			int width = payNowdisp.getWidth();
			int height = payNowdisp.getHeight();
			progresDialog.getWindow().setLayout((width / 2), (height / 4));
			progresDialog.getWindow().setBackgroundDrawable(
					new ColorDrawable(android.graphics.Color.TRANSPARENT));
			progresDialog.getWindow().setGravity(Gravity.CENTER_VERTICAL);
			View CreditdialogLayout = ((Activity) contxt).getLayoutInflater()
					.inflate(R.layout.custom_progressbar, null);
			progressTxt = (TextView) CreditdialogLayout
					.findViewById(R.id.progressTitle);
			if (isSavePdf) {
				progressTxt.setText("Saving pdf, Please wait...");
			} else {
				progressTxt.setText("Creating Report, Please wait...");
			}

			if (isForSendEmail) {
				progressTxt.setText("Creating pdf, Please wait...");
			}

			if (saveListener != null) {
				progressTxt.setText("Creating pdf, Please wait...");
			}

			progresDialog.setContentView(CreditdialogLayout);
			progresDialog.show();
			progresDialog.setCancelable(false);
			super.onPreExecute();
		}

		String path;
		@Override
		protected String doInBackground(String... params) {
			try {

				DisplayMetrics metrics = contxt.getResources()
						.getDisplayMetrics();
				float density = metrics.densityDpi / 100;
				if (!TextUtils.isEmpty(sdCardLocation)) {
					FileOutputStream file = null;
					if (isSavePdf) {
						/*filename = testInfo.fname + "_" + testInfo.lname + "_"
								+ reportItem.getTestname() + "_"
								+ reportItem.getTestInfoId() + "_"
								+ System.currentTimeMillis() + ".pdf"; */
						
						SimpleDateFormat dateFormat = new SimpleDateFormat("yyMMdd");
						Date date = new Date();
						
						filename = "ColorDx" + "_" + testInfo.fname + "_" +testInfo.lname + "_"+ dateFormat.format(date) + ".pdf";
						
						path = sdCardLocation + "/" + filename;
					} else {
						filename = testInfo.fname + "_" + testInfo.lname + "_"
								+ reportItem.getTestname()
								+ reportItem.getTestInfoId() + "_"
								+ System.currentTimeMillis() + "_report.pdf";
						path = sdCardLocation + "/" + filename;
					}
					filename = AppUtils.getReplacedPath(filename);
					path = AppUtils.getReplacedPath(path);
					file = new FileOutputStream(new File(path));

					TestContentManager.getInstance().setPdfFilePath(path);

					String[] imagesPaths = reportItem.getGraphResultPath()
							.split(":");

					Image headerImage = PngImage.getImage(imagesPaths[0]);
					Image headerTextImage = PngImage.getImage(contxt
							.getAssets().open(imagesPaths[1]));
					Image userDetailsImage = PngImage.getImage(imagesPaths[2]);
					Image testnameStripImage = PngImage
							.getImage(imagesPaths[3]);
					Image testResultViewImage = PngImage
							.getImage(imagesPaths[4]);
					Image testMessageImage = PngImage.getImage(imagesPaths[5]);

					Document document = new Document();
					// document.setPageSize(new Rectangle(1250f, 1430f));
					// set page size to fit to screen resolution
					WindowManager wm = (WindowManager) contxt
							.getSystemService(Context.WINDOW_SERVICE);
					Display display = wm.getDefaultDisplay();
					Point outSize = new Point();
					display.getSize(outSize);
					float pageWidth = outSize.x + 200;
					if(pageWidth < 1250f)
						pageWidth = 1250f;
					document.setPageSize(new Rectangle(pageWidth, 2800));

					PdfWriter.getInstance(document, file);
					document.open();
					if (reportItem.isColorShown()) {
						isColorShown = true;
					} else {
						isColorShown = false;
					}

					float topPadding = document.getPageSize().getHeight();

					// Add Logo header image
					headerImage.setAlignment(Image.UNDERLYING
							| Image.ALIGN_CENTER);
					headerImage.scaleToFit(document.getPageSize().getWidth(),
							document.getPageSize().getHeight());
					topPadding = topPadding - headerImage.getHeight();
					document.add(headerImage);

					// Add logo text image
					headerTextImage.setAlignment(Image.ALIGN_CENTER);
					topPadding = topPadding - headerTextImage.getHeight()
							- headerTextImage.getHeight();
					headerTextImage.setAbsolutePosition((document.getPageSize()
							.getWidth() - headerTextImage.getWidth()) / 2,
							topPadding + (5 * density));

					document.add(headerTextImage);

					// Add user details image
					userDetailsImage.setAlignment(Image.ALIGN_CENTER
							| Image.ORIGINAL_PNG);
					topPadding = topPadding - userDetailsImage.getHeight();
					// userDetailsImage
					// .setAbsolutePosition(
					// (document.getPageSize().getWidth() - userDetailsImage
					// .getWidth()) / 2, topPadding);
					userDetailsImage
							.setAbsolutePosition(
									(document.getPageSize().getWidth() - userDetailsImage
											.getWidth()) / 3, topPadding);

					if (DevConfig.PDF_RETINA_PRINT_TESTING) {
						// userDetailsImage.scaleToFit(document.getPageSize()
						// .getWidth(), userDetailsImage.getHeight());

						// userDetailsImage.scaleToFit(userDetailsImage.getWidth(),
						// userDetailsImage.getHeight());
					}

					document.add(userDetailsImage);

					// Add test name strip image
					testnameStripImage.setAlignment(Image.ORIGINAL_PNG);
					topPadding = topPadding - testnameStripImage.getHeight();
					testnameStripImage
							.setAbsolutePosition(
									(document.getPageSize().getWidth() - testnameStripImage
											.getWidth()) / 2, topPadding
											- (5 * density));
					if (DevConfig.PDF_RETINA_PRINT_TESTING) {
						// testnameStripImage.scaleAbsolute(
						// testnameStripImage.getWidth(),
						// testnameStripImage.getHeight());
						// testnameStripImage.scaleToFit(document.getPageSize().getWidth(),
						// document.getPageSize().getHeight());
					}
					document.add(testnameStripImage);

					// Add result view image
					testResultViewImage.setAlignment(Image.ALIGN_CENTER
							| Image.ORIGINAL_PNG);
					topPadding = topPadding - testResultViewImage.getHeight()
							- (15 * density);
					testResultViewImage
							.setAbsolutePosition((document.getPageSize()
									.getWidth() - testResultViewImage
									.getWidth()) / 3, topPadding);
					document.add(testResultViewImage);

					// Add result message strip image
					testMessageImage.setAlignment(Image.ORIGINAL_PNG);
					topPadding = topPadding - testMessageImage.getHeight()
							- (15 * density);
					testMessageImage
							.setAbsolutePosition(
									(document.getPageSize().getWidth() - testMessageImage
											.getWidth()) / 2, topPadding);
					document.add(testMessageImage);

					// Add bottom image
					Image bottomImage = PngImage.getImage(contxt.getAssets()
							.open(imagesPaths[6]));

					final float x = (document.getPageSize().getWidth() - testnameStripImage
							.getWidth()) / 2;
					final float w = document.getPageSize().getWidth() - (x * 2);
					final float percentage = 100 * w / bottomImage.getWidth();
					final float h = bottomImage.getHeight() * percentage / 100;
					// scale footer image to fit to the width, maintain aspect ratio
					bottomImage.scaleAbsoluteWidth(w);
					bottomImage.scaleAbsoluteHeight(h);

					bottomImage.setAlignment(Image.ORIGINAL_PNG);
					// topPadding = topPadding - bottomImage.getHeight() - (15 * density);
					topPadding = topPadding - h - (15 * density);
					bottomImage.setAbsolutePosition(x, topPadding);
					document.add(bottomImage);  

					document.newPage();
					document.close();
					file.close();
					success = true;
					pdfIntentValue = path;

					if (saveListener != null) {
						saveListener.onSaved(new File(path));
					}
				} else {
					pdfIntentValue = "No SD card mounted";
					message = "No SD Card";
					success = false;
				}
			} catch (Exception e) {
				message = e.toString();
				pdfIntentValue = message;
				success = false;
				e.printStackTrace();
			}
			return null;
		}

		@Override
		protected void onPostExecute(String result) {
			if (contxt != null) {
				progresDialog.dismiss();
				if (success) {
					if (isForSendEmail) {
						pdfIntent = new Intent(
								ActionUpdateListener.ACTION_PDF_GENERATED);
					}
					if (isPrintPdf) {
						printPDFpath = path;
						pdfIntent = new Intent(
								ActionUpdateListener.ACTION_PDF_PRINT);
					} else {
						if (saveListener == null) {
							AlertDialog.Builder alert = new AlertDialog.Builder(
									contxt);
							alert.setCancelable(false).setMessage(
									isSavePdf ? "Saved Successfully." : "Download Successfully.");
							alert.setNegativeButton(contxt.getResources()
									.getString(R.string.ok_text),
									new DialogInterface.OnClickListener() {
										@Override
										public void onClick(
												DialogInterface dialog,
												int which) {
											dialog.cancel();
										}
									});
							alert.show();

							Toast.makeText(
									contxt,
									success
											? "Flie Stored at: " + path
											: "SDCard required!",
									Toast.LENGTH_SHORT).show();
						}
					}
				} else {
					if (isForSendEmail) {
						pdfIntent = new Intent(
								ActionUpdateListener.ACTION_PDF_ERROR);
					} else {
						AlertDialog.Builder alert = new AlertDialog.Builder(
								contxt);
						alert.setCancelable(false).setMessage(message);
						alert.setNegativeButton(contxt.getResources()
								.getString(R.string.ok_text),
								new DialogInterface.OnClickListener() {
									@Override
									public void onClick(DialogInterface dialog,
											int which) {
										dialog.cancel();
									}
								});
						alert.show();
					}
				}
				if (isForSendEmail) {
					pdfIntent.putExtra("pdf_message", pdfIntentValue);
					pdfIntent.putExtra("pdf_name", filename);
					contxt.sendBroadcast(pdfIntent);
				} else if (isPrintPdf) {
					pdfIntent.putExtra("pdf_message", pdfIntentValue);
					pdfIntent.putExtra("pdf_name", path);
					contxt.sendBroadcast(pdfIntent);
					Log.i(getClass().getName(), "Print Requested!");
				}
				super.onPostExecute(result);
			}
		}
	}

	/**
	 * @param mTestTakenDate
	 * @param mTestResult
	 * @param mNoOfQues
	 * @param mCorrectAnsCount
	 * @param allowDeficiency
	 * @param mDefNoOfQues
	 * @param mDefCorrectAnsCount
	 * @param mEmail
	 *            *
	 * 
	 * 
	 */
	public static void downloadPDFDocument1(Context context, int TestInfoId,
			Testsummary mGroup, ArrayList<Testsummary> mChild) {
		// public static void downloadPDFDocument(Context context,int TestId){
		contxt = context;
		mDiagnosisDetails = new Diagnosisdetails();
		testsummary = mGroup;
		childList = mChild;
		diagnosisManager = new DiagnosisdetailsManager(contxt) {
			public void handleMessage(android.os.Message msg) {
				if (msg.getData()
						.getString("Operation")
						.equals(EOperation.GET_SINGLE_DIAGNOSISDETAILS
								.toString())) {
					mDiagnosisDetails = (Diagnosisdetails) msg.obj;
					if (mDiagnosisDetails != null) {
						mfName = mDiagnosisDetails.fName;
						mLName = mDiagnosisDetails.lName;
						mTestName = mDiagnosisDetails.Testname;
						mCreatedDate = mDiagnosisDetails.Createddate;
						mDiagnosisMsg = mDiagnosisDetails.Diagnosismessage;
						mScoreMsg = mDiagnosisDetails.Scoremessage;
						new CreatDocumentASync().execute();
					} else {
						/*
						 * AlertDialog.Builder alert = new
						 * AlertDialog.Builder(contxt);
						 * alert.setCancelable(false
						 * ).setMessage("Synchronizing....plz wait...");
						 * alert.setNegativeButton(getString(R.string.ok_text),
						 * new DialogInterface.OnClickListener() {
						 * 
						 * @Override public void onClick(DialogInterface dialog,
						 * int which) { dialog.cancel();
						 * 
						 * } }); alert.show();
						 */

						mfName = testsummary.FirstName;
						mLName = testsummary.LastName;
						mTestName = testsummary.TestName;
						mCreatedDate = testsummary.Date;
						mDiagnosisMsg = getDiagosisMessage(testsummary,
								childList);
						mScoreMsg = getScoreMessage(testsummary, childList);
						new CreatDocumentASync().execute();
					}
				}

			};
		};
		try {
			diagnosisManager.getSingleDiagnosisdetails(TestInfoId);
		} catch (DiagnosisdetailsException e) {
			e.printStackTrace();
		}
	}

	/**
	 * 
	 * Creates Certificate in PDF format.
	 * 
	 */
	public static class CreatDocumentASync
			extends
				AsyncTask<String, String, String> {
		boolean success = false;
		String sdCardLocation = Environment.getExternalStorageDirectory()
				.toString();
		Dialog progresDialog;
		TextView progressTxt;
		String message;

		@Override
		protected void onPreExecute() {
			progresDialog = new Dialog(contxt, R.style.Theme_Levels);
			Display payNowdisp = ((Activity) contxt).getWindowManager()
					.getDefaultDisplay();
			int width = payNowdisp.getWidth();
			int height = payNowdisp.getHeight();
			progresDialog.getWindow().setLayout((width / 3), (height / 4));
			progresDialog.getWindow().setBackgroundDrawable(
					new ColorDrawable(android.graphics.Color.TRANSPARENT));
			progresDialog.getWindow().setGravity(Gravity.CENTER_VERTICAL);
			View CreditdialogLayout = ((Activity) contxt).getLayoutInflater()
					.inflate(R.layout.custom_progressbar, null);
			progressTxt = (TextView) CreditdialogLayout
					.findViewById(R.id.progressTitle);
			progressTxt.setText("Creating certficate! please wait...");
			progresDialog.setContentView(CreditdialogLayout);
			progresDialog.show();
			progresDialog.setCancelable(false);
			super.onPreExecute();
		}

		@Override
		protected String doInBackground(String... params) {
			try {
				if (sdCardLocation != null && !sdCardLocation.equals("")) {
					FileOutputStream file = new FileOutputStream(new File(
							sdCardLocation + "/" + mfName + "_" + mLName + "_"
									+ mTestName + "certificate.pdf"));
					Document document = new Document();
					document.setPageSize(new Rectangle(1056f, 832f));
					PdfWriter.getInstance(document, file);
					document.open();
					Image image = PngImage.getImage(contxt.getAssets().open(
							"certificate.png"));
					image.setAlignment(Image.UNDERLYING | Image.ALIGN_CENTER);
					image.scaleToFit(document.getPageSize().getWidth() - 10f,
							document.getPageSize().getHeight() - 10f);
					document.add(image);
					Font lightblue = new Font(Font.FontFamily.TIMES_ROMAN, 18f,
							Font.BOLD, new BaseColor(66, 100, 90));
					Chunk multiLineLineChunk = new Chunk("\n\n\n\n\n",
							lightblue);
					Chunk userNameChunk = new Chunk("User Name            :  "
							+ mfName + " " + mLName, lightblue);
					Chunk testTakenChunk = new Chunk(
							"Test Taken            :  " + mTestName, lightblue);
					Chunk dateTimeChunk = new Chunk("Date & Time         :  "
							+ mCreatedDate, lightblue);
					Chunk diagnosisChunk = new Chunk(
							"Diagnosis               :  " + mDiagnosisMsg,
							lightblue);
					mScoreMsg = mScoreMsg.replaceAll("\\<[^>]*>", "");
					String[] splitCurrentString = mScoreMsg.split("\n");
					Chunk scoreChunk = null;
					Chunk scoreChunk1 = null, scoreChunk2 = null, scoreChunk3 = null;
					Phrase p2 = new Phrase();
					if (splitCurrentString != null
							&& splitCurrentString.length > 0) {
						scoreChunk = new Chunk("Score                      :  "
								+ splitCurrentString[0], lightblue);

						if (splitCurrentString.length >= 2) {
							scoreChunk1 = new Chunk(
									"                                    "
											+ splitCurrentString[1], lightblue);

							if (splitCurrentString.length >= 3) {
								scoreChunk2 = new Chunk(
										"                                   "
												+ splitCurrentString[2],
										lightblue);
								if (splitCurrentString.length >= 4) {
									scoreChunk3 = new Chunk(
											"                                    "
													+ splitCurrentString[3],
											lightblue);
								} else {
									scoreChunk3 = new Chunk(" ", lightblue);
								}
							} else {
								scoreChunk2 = new Chunk(" ", lightblue);
							}
						} else {
							scoreChunk1 = new Chunk(" ", lightblue);
						}
					}
					p2.add(multiLineLineChunk);
					p2.add(Chunk.NEWLINE);
					p2.add(userNameChunk);
					p2.add(Chunk.NEWLINE);
					p2.add(Chunk.NEWLINE);
					p2.add(testTakenChunk);
					p2.add(Chunk.NEWLINE);
					p2.add(Chunk.NEWLINE);
					p2.add(dateTimeChunk);
					p2.add(Chunk.NEWLINE);
					p2.add(Chunk.NEWLINE);
					p2.add(diagnosisChunk);
					p2.add(Chunk.NEWLINE);
					p2.add(Chunk.NEWLINE);
					p2.add(scoreChunk);
					p2.add(Chunk.NEWLINE);
					p2.add(scoreChunk1);
					p2.add(Chunk.NEWLINE);
					p2.add(scoreChunk2);
					p2.add(Chunk.NEWLINE);
					p2.add(scoreChunk3);
					p2.add(Chunk.NEWLINE);

					Paragraph p = new Paragraph();
					p.setAlignment(Chunk.ALIGN_LEFT);
					p.setSpacingBefore(100f);
					p.setIndentationLeft(230f);
					p.add(p2);
					document.add(p);
					document.newPage();
					document.close();
					file.close();
					success = true;
				} else {
					message = "No SD Card";
					success = false;
					// AlertDialog.Builder alert = new
					// AlertDialog.Builder(contxt);
					// alert.setCancelable(false).setMessage("No SD Card");
					// alert.setNegativeButton(getString(R.string.ok_text),
					// new DialogInterface.OnClickListener() {
					// @Override
					// public void onClick(DialogInterface dialog,
					// int which) {
					// dialog.cancel();
					// }
					// });
					// alert.show();
				}
			} catch (Exception e) {
				message = e.toString();
				success = false;
				e.printStackTrace();
				// AlertDialog.Builder alert = new AlertDialog.Builder(contxt);
				// alert.setCancelable(false).setMessage("" + e.toString());
				// alert.setNegativeButton(getString(R.string.ok_text),
				// new DialogInterface.OnClickListener() {
				// @Override
				// public void onClick(DialogInterface dialog,
				// int which) {
				// dialog.cancel();
				// }
				// });
				// alert.show();
			}
			return null;
		}

		@Override
		protected void onPostExecute(String result) {
			progresDialog.dismiss();
			if (success) {
				AlertDialog.Builder alert = new AlertDialog.Builder(contxt);
				alert.setCancelable(false).setMessage("Download Successfully.");
				alert.setNegativeButton(
						contxt.getResources().getString(R.string.ok_text),
						new DialogInterface.OnClickListener() {
							@Override
							public void onClick(DialogInterface dialog,
									int which) {
								dialog.cancel();
							}
						});
				alert.show();
				Toast.makeText(
						contxt,
						success ? "Flie Stored at: " + sdCardLocation + "/"
								+ mfName + "_" + mLName + "_" + mTestName
								+ "certificate.pdf" : "SDCard required!",
						Toast.LENGTH_SHORT).show();
			} else {
				AlertDialog.Builder alert = new AlertDialog.Builder(contxt);
				alert.setCancelable(false).setMessage(message);
				alert.setNegativeButton(
						contxt.getResources().getString(R.string.ok_text),
						new DialogInterface.OnClickListener() {
							@Override
							public void onClick(DialogInterface dialog,
									int which) {
								dialog.cancel();
							}
						});
				alert.show();
			}
			super.onPostExecute(result);
		}
	}

	private static String getScoreMessage(Testsummary mGroup,
			ArrayList<Testsummary> mChild) {
		String score = "General Test    "
				+ mGroup.TestScore
				+ "/"
				+ (mGroup.NoOfQues - mGroup.dempPlatesCnt)
				+ "  "
				+ (mGroup.Results.equals("0")
						? "(<font color='#FF0000'>Failed</font>)" + "<br/> \n"
						: "(<font color='#1E940A'>Passed</font>)" + ".<br/> \n");
		if (mChild.size() != 0) {
			if (mChild.get(0) != null)
				score += "   Protan(red)      "
						+ mChild.get(0).TestScore
						+ "/"
						+ (mChild.get(0).NoOfQues - mChild.get(0).dempPlatesCnt)
						+ "    "
						+ (mChild.get(0).Results.equals("Pass")
								? "(<font color='#1E940A'>Passed</font>)"
										+ "<br/> \n"
								: "<font color='#FF0000'>"
										+ mChild.get(0).Results + "</font>"
										+ "<br/> \n");
			if (mChild.get(1) != null)
				score += "   Deutan(green)  "
						+ mChild.get(1).TestScore
						+ "/"
						+ (mChild.get(1).NoOfQues - mChild.get(1).dempPlatesCnt)
						+ "   "
						+ (mChild.get(1).Results.equals("Pass")
								? "(<font color='#1E940A'>Passed</font>)"
										+ "<br/> \n"
								: "<font color='#FF0000'>"
										+ mChild.get(1).Results + "</font>"
										+ "<br/> \n");
			if (mChild.get(2) != null)
				score += "   Tritan(blue)      "
						+ mChild.get(2).TestScore
						+ "/"
						+ (mChild.get(2).NoOfQues - mChild.get(2).dempPlatesCnt)
						+ "    "
						+ (mChild.get(2).Results.equals("Pass")
								? "(<font color='#1E940A'>Passed</font>)"
										+ "<br/> \n"
								: "<font color='#FF0000'>"
										+ mChild.get(2).Results + "</font>"
										+ "<br/> ");
			score += "";
		}
		return score;
	}

	/**
	 * 
	 * @param childList2
	 * @param testsummary
	 * @return
	 */
	private static String getDiagosisMessage(Testsummary testsummary,
			ArrayList<Testsummary> childList) {
		String diagnosisMessage = "Normal Color Vision.";
		Testsummary sectionOneTestResult = testsummary;
		Testsummary sectionTwoTestResult = null;
		Testsummary sectionThreeTestResult = null;
		Testsummary sectionFourTestResult = null;
		if (childList.size() != 0) {
			sectionTwoTestResult = childList.get(0);
			sectionThreeTestResult = childList.get(1);
			sectionFourTestResult = childList.get(2);
		}

		// Check if deficiency tests exists for this main test.
		if (sectionTwoTestResult != null) {
			// User has taken deficiency tests.
			if (sectionTwoTestResult.Results.equals("Pass")
					&& sectionThreeTestResult.Results.equals("Pass")
					&& sectionFourTestResult.Results.equals("Pass")) {

				// User have passed in all deficiency tests.
				if (sectionOneTestResult.Results.equals("0")) {
					diagnosisMessage = "Questionable - Recommend additional testing.";
				}
			} else {
				// If user fails in any deficiency test.. construct the
				// appropriate message for the same.
				diagnosisMessage = checkDeficiencyTestResult(
						sectionTwoTestResult, sectionThreeTestResult,
						sectionFourTestResult);
			}
		} else {
			if (sectionOneTestResult.Results.equals("0")) {
				diagnosisMessage = "You have a Color Vision Deficiency.";
			}
		}
		return diagnosisMessage;
	}

	private static String checkDeficiencyTestResult(Testsummary section2,
			Testsummary section3, Testsummary section4) {
		String deficiencyMessage = "";
		if (!section4.Results.equals("Pass")) {
			deficiencyMessage = ((section4.TestScore >= section4.MildScoreMin)
					&& (section4.TestScore <= section4.MildScoreMax)
					? "Mild Tritan"
					: ((section4.TestScore >= section4.ModScoreMin)
							&& (section4.TestScore <= section4.ModScoreMax)
							? "Moderate Tritan"
							: (section4.TestScore >= section4.SevScoreMin)
									&& (section4.TestScore <= section4.SevScoreMax)
									? "Severe  Tritan"
									: ""));
		}

		if (section2.TestScore != section3.TestScore) {
			if (section2.TestScore < section3.TestScore) {
				deficiencyMessage += ((section2.TestScore >= section2.MildScoreMin)
						&& (section2.TestScore <= section2.MildScoreMax)
						? "Mild Protan"
						: ((section2.TestScore >= section2.ModScoreMin)
								&& (section2.TestScore <= section2.ModScoreMax)
								? "Moderate Protan"
								: (section2.TestScore >= section2.SevScoreMin)
										&& (section2.TestScore <= section2.SevScoreMax)
										? "Severe Protan"
										: ""));
				deficiencyMessage += ((section3.TestScore >= section3.MildScoreMin)
						&& (section3.TestScore <= section3.MildScoreMax)
						? "Mild Deutan"
						: ((section3.TestScore >= section3.ModScoreMin)
								&& (section3.TestScore <= section3.ModScoreMax)
								? "Moderate Deutan"
								: (section3.TestScore >= section3.SevScoreMin)
										&& (section3.TestScore <= section3.SevScoreMax)
										? "Severe Deutan"
										: ""));
			} else {
				deficiencyMessage += ((section3.TestScore >= section3.MildScoreMin)
						&& (section3.TestScore <= section3.MildScoreMax)
						? "Mild Deutan"
						: ((section3.TestScore >= section3.ModScoreMin)
								&& (section3.TestScore <= section3.ModScoreMax)
								? "Moderate Deutan"
								: (section3.TestScore >= section3.SevScoreMin)
										&& (section3.TestScore <= section3.SevScoreMax)
										? "Severe Deutan"
										: ""));
				deficiencyMessage += ((section2.TestScore >= section2.MildScoreMin)
						&& (section2.TestScore <= section2.MildScoreMax)
						? "Mild Protan"
						: ((section2.TestScore >= section2.ModScoreMin)
								&& (section2.TestScore <= section2.ModScoreMax)
								? "Moderate Protan"
								: (section2.TestScore >= section2.SevScoreMin)
										&& (section2.TestScore <= section2.SevScoreMax)
										? "Severe Protan"
										: ""));
			}
		} else {
			if (!section2.Results.equals("Pass")) {
				deficiencyMessage += ((section2.TestScore >= section2.MildScoreMin)
						&& (section2.TestScore <= section2.MildScoreMax)
						? "Mild Protan"
						: ((section2.TestScore >= section2.ModScoreMin)
								&& (section2.TestScore <= section2.ModScoreMax)
								? "Moderate Protan"
								: (section2.TestScore >= section2.SevScoreMin)
										&& (section2.TestScore <= section2.SevScoreMin)
										? "Severe Protan"
										: ""));

			}
			if (!section3.Results.equals("Pass")) {
				deficiencyMessage += ((section3.TestScore >= section3.MildScoreMin)
						&& (section3.TestScore <= section3.MildScoreMax)
						? "Mild Deutan"
						: ((section3.TestScore >= section3.ModScoreMin)
								&& (section3.TestScore <= section3.ModScoreMax)
								? "Moderate Deutan"
								: (section3.TestScore >= section3.SevScoreMin)
										&& (section3.TestScore <= section3.SevScoreMin)
										? "Severe Deutan"
										: ""));
			}
		}

		return deficiencyMessage;
	}

	/**
	 * Returns the blob data for the image.
	 * 
	 * @param imageUrl
	 * @return
	 */
	public static boolean storeImageOnMemory(Context activity, String imageUrl) {
		boolean result = false;
		InputStream ins = null;
		ByteArrayOutputStream out = null;
		if (!TextUtils.isEmpty(imageUrl)) {
			try {
				HttpGet httpRequest = null;
				httpRequest = new HttpGet(imageUrl);
				HttpClient httpclient = new DefaultHttpClient();
				HttpResponse response = (HttpResponse) httpclient
						.execute(httpRequest);
				HttpEntity entity = response.getEntity();
				BufferedHttpEntity bufHttpEntity = new BufferedHttpEntity(
						entity);
				ins = bufHttpEntity.getContent();
				if (ins != null) {
					out = new ByteArrayOutputStream();
					if (ins != null) {
						out = new ByteArrayOutputStream();
						byte[] byteData = new byte[2048];
						int byteRead = ins.read(byteData);
						while (byteRead >= 0) {
							out.write(byteData, 0, byteRead);
							byteRead = ins.read(byteData);
						}
						byteData = null;
						String[] tempArr = imageUrl.split("/");
						FileOutputStream outStream = new FileOutputStream(
								String.format(activity.getFilesDir()
										+ "/test_images/%s",
										tempArr[tempArr.length - 1]));
						outStream.write(out.toByteArray());
						outStream.close();
						result = true;
					}

				}
			} catch (Exception e) {
				e.printStackTrace();
			} finally {
				try {
					if (out != null) {
						out.close();
					}
					if (ins != null) {
						ins.close();
					}
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		} else {
			Log.d("TEST", "Image URL is null/empty :: ");
		}
		return result;
	}

	/**
	 * store image file in JPG format on SDCARD
	 */
	public static boolean storeImageOnMemory1(Context activity, String url) {
		boolean result = false;
		try {
			FileOutputStream outStream = null;
			URLConnection connection = new URL(url).openConnection();
			InputStream stream = connection.getInputStream();
			BufferedInputStream in = new BufferedInputStream(stream);
			ByteArrayOutputStream out = new ByteArrayOutputStream(1024);
			int read;
			byte[] b = new byte[128];
			while ((read = in.read(b)) != -1) {
				out.write(b, 0, read);
			}
			byte[] byteArray = out.toByteArray();
			out.flush();
			out.close();

			String[] tempArr = url.split("/");
			outStream = new FileOutputStream(String.format(
					activity.getFilesDir() + "/test_images/%s",
					tempArr[tempArr.length - 1]));
			outStream.write(byteArray);
			outStream.close();
			result = true;
		} catch (Exception e) {
			result = false;
			e.printStackTrace();
			Log.d("TEST", "storeImageOnMemory : Exception :" + e.getMessage());
			AppUtils.writeDataToFile("storeImageOnMemory : Exception :"
					+ e.getMessage());
		}
		Log.d("TEST", "storeImageOnMemory :" + url + " **** Sucesss/Fail :"
				+ result);
		AppUtils.writeDataToFile("storeImageOnMemory :" + url
				+ " **** Sucesss/Fail :" + result);
		return result;
	}

	private InputStream OpenHttpConnection(String urlString) throws IOException {
		InputStream in = null;
		int response = -1;

		URL url = new URL(urlString);
		URLConnection conn = url.openConnection();

		if (!(conn instanceof HttpURLConnection))
			throw new IOException("Not an HTTP connection");

		try {
			HttpURLConnection httpConn = (HttpURLConnection) conn;
			httpConn.setAllowUserInteraction(false);
			httpConn.setInstanceFollowRedirects(true);
			httpConn.setRequestMethod("GET");
			httpConn.connect();

			response = httpConn.getResponseCode();
			if (response == HttpURLConnection.HTTP_OK) {
				in = httpConn.getInputStream();
			}
		} catch (Exception ex) {
			throw new IOException("Error connecting");
		}
		return in;
	}

	private Bitmap DownloadImage(String URL) {
		Bitmap bitmap = null;
		InputStream in = null;
		try {
			in = OpenHttpConnection(URL);
			bitmap = BitmapFactory.decodeStream(in);
			in.close();
		} catch (IOException e1) {
			e1.printStackTrace();
		}
		return bitmap;
	}

	public static byte[] getBytesFromFile(InputStream is) {
		byte[] bytes = null;
		if (is != null) {
			try {
				bytes = new byte[(int) is.available()];
				int offset = 0;
				int numRead = 0;
				while (offset < bytes.length
						&& (numRead = is.read(bytes, offset, bytes.length
								- offset)) >= 0) {
					offset += numRead;
				}
				if (offset < bytes.length) {
					throw new IOException("Could not completely read file ");
				}
				is.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		return bytes;
	}

	// public static byte[] getBytesFromFile(String imagePath) {
	// File file = new File(imagePath);
	// byte[] bytes = null;
	// try {
	// InputStream is = new FileInputStream(file);
	// long length = file.length();
	// bytes = new byte[(int) length];
	// int offset = 0;
	// int numRead = 0;
	// while (offset < bytes.length
	// && (numRead = is.read(bytes, offset, bytes.length - offset)) >= 0) {
	// offset += numRead;
	// }
	// if (offset < bytes.length) {
	// throw new IOException("Could not completely read file "
	// + file.getName());
	// }
	// is.close();
	// } catch (IOException e) {
	// e.printStackTrace();
	// }
	// return bytes;
	// }
	public static Bitmap decodeSampledBitmapFromResource(byte[] imag,
			int reqWidth, int reqHeight) {

		// First decode with inJustDecodeBounds=true to check dimensions
		final BitmapFactory.Options options = new BitmapFactory.Options();
		options.inJustDecodeBounds = true;
		BitmapFactory.decodeByteArray(imag, 0, imag.length, options);

		// Calculate inSampleSize
		options.inSampleSize = calculateInSampleSize(options, reqWidth,
				reqHeight);

		// Decode bitmap with inSampleSize set
		options.inJustDecodeBounds = false;
		return BitmapFactory.decodeByteArray(imag, 0, imag.length, options);
	}

	public static int calculateInSampleSize(BitmapFactory.Options options,
			int reqWidth, int reqHeight) {
		// Raw height and width of image
		final int height = options.outHeight;
		final int width = options.outWidth;
		int inSampleSize = 1;

		if (height > reqHeight || width > reqWidth) {

			// Calculate ratios of height and width to requested height and
			// width
			final int heightRatio = Math.round((float) height
					/ (float) reqHeight);
			final int widthRatio = Math.round((float) width / (float) reqWidth);

			// Choose the smallest ratio as inSampleSize value, this will
			// guarantee
			// a final image with both dimensions larger than or equal to the
			// requested height and width.
			inSampleSize = heightRatio < widthRatio ? heightRatio : widthRatio;
		}

		return inSampleSize;
	}
}
